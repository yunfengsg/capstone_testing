var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/tsup/assets/esm_shims.js
import { fileURLToPath } from "url";
import path from "path";
var init_esm_shims = __esm({
  "node_modules/tsup/assets/esm_shims.js"() {
    "use strict";
  }
});

// src/index.ts
import sinon from "sinon";
import traverse from "neotraverse/legacy";
import { Readable } from "stream";
import AWS_SDK from "aws-sdk";
var require_src = __commonJS({
  "src/index.ts"(exports, module) {
    init_esm_shims();
    var _AWS = AWS_SDK;
    var AWS = {
      Promise: global.Promise,
      mock,
      remock,
      restore,
      setSDK,
      setSDKInstance
    };
    var services = {};
    async function setSDK(path2) {
      _AWS = __require(path2);
    }
    function setSDKInstance(sdk) {
      _AWS = sdk;
    }
    function mock(service, method, replace) {
      if (!services[service]) {
        const service_to_add = {
          // Save the real constructor so we can invoke it later on.
          // Uses traverse for easy access to nested services (dot-separated)
          Constructor: traverse(_AWS).get(service.split(".")),
          methodMocks: {},
          invoked: false
        };
        services[service] = service_to_add;
        mockService(service);
      }
      const serviceObj = services[service];
      const methodName = method;
      if (!serviceObj.methodMocks[methodName]) {
        if (serviceObj !== void 0) serviceObj.methodMocks[methodName] = { replace };
        if (serviceObj.invoked) {
          serviceObj.clients?.forEach((client) => {
            mockServiceMethod(service, client, methodName, replace);
          });
        }
      }
      const methodMockObj = serviceObj.methodMocks[methodName];
      return methodMockObj;
    }
    function remock(service, method, replace) {
      if (services[service]?.methodMocks[method]) {
        restoreMethod(service, method);
        const service_obj = services[service];
        if (service_obj !== void 0) {
          service_obj.methodMocks[method] = {
            replace
          };
        }
      }
      const methodName = method;
      if (services[service]?.invoked) {
        services[service]?.clients?.forEach((client) => {
          mockServiceMethod(service, client, methodName, replace);
        });
      }
      return services[service]?.methodMocks[method];
    }
    function mockService(service) {
      const nestedServices = service.split(".");
      const method = nestedServices.pop();
      const object = traverse(_AWS).get(nestedServices);
      const service_obj = services[service];
      if (service_obj) {
        const serviceStub = sinon.stub(object, method).callsFake(function(...args) {
          service_obj.invoked = true;
          const client = new service_obj.Constructor(...args);
          service_obj.clients = service_obj.clients || [];
          service_obj.clients.push(client);
          for (const key in service_obj.methodMocks) {
            const methodKey = key;
            const objectMethodMock = service_obj.methodMocks[key];
            if (objectMethodMock) {
              mockServiceMethod(service, client, methodKey, objectMethodMock.replace);
            }
          }
          return client;
        });
        service_obj.stub = serviceStub;
      }
    }
    function wrapTestStubReplaceFn(replace) {
      if (typeof replace !== "function" || !(replace._isMockFunction || replace.isSinonProxy)) {
        return replace;
      }
      return (params, callback) => {
        let cb;
        if (callback === void 0 || !callback) {
          cb = params;
        } else {
          cb = callback;
        }
        const cbSpy = sinon.spy(cb);
        try {
          const result = replace.length === 1 ? replace(cbSpy) : replace(params, cbSpy);
          if (cbSpy.called) {
            return;
          }
          if (typeof result.then === "function") {
            result.then(
              /* istanbul ignore next */
              (val) => cb(void 0, val),
              (err) => {
                return cb(err);
              }
            );
          } else {
            cb(void 0, result);
          }
        } catch (err) {
          cb(err);
        }
      };
    }
    function mockServiceMethod(service, client, method, replace) {
      replace = wrapTestStubReplaceFn(replace);
      const service_obj = services[service];
      const serviceMethodMock = service_obj.methodMocks[method];
      serviceMethodMock.stub = sinon.stub(client, method).callsFake(function() {
        const args = Array.prototype.slice.call(arguments);
        let userArgs;
        let userCallback;
        if (typeof args[(args.length || 1) - 1] === "function") {
          userArgs = args.slice(0, -1);
          userCallback = args[(args.length || 1) - 1];
        } else {
          userArgs = args;
        }
        const havePromises = typeof AWS.Promise === "function";
        let promise;
        let resolve;
        let reject;
        let storedResult;
        const tryResolveFromStored = function() {
          if (storedResult && promise) {
            if (typeof storedResult.then === "function") {
              storedResult.then(resolve, reject);
            } else if (storedResult.reject) {
              reject(storedResult.reject);
            } else {
              resolve(storedResult.resolve);
            }
          }
        };
        const callback = function(err, data) {
          if (!storedResult) {
            if (err) {
              storedResult = { reject: err };
            } else {
              storedResult = { resolve: data };
            }
          }
          if (userCallback) {
            userCallback(err, data);
          }
          tryResolveFromStored();
        };
        const request = {
          promise: havePromises ? function() {
            if (!promise) {
              promise = new AWS.Promise(function(resolve_, reject_) {
                resolve = resolve_;
                reject = reject_;
              });
            }
            tryResolveFromStored();
            return promise;
          } : void 0,
          createReadStream: function() {
            if (storedResult instanceof Readable) {
              return storedResult;
            }
            if (replace instanceof Readable) {
              return replace;
            } else {
              const stream = new Readable();
              stream._read = function() {
                if (typeof replace === "string" || Buffer.isBuffer(replace)) {
                  this.push(replace);
                }
                this.push(null);
              };
              return stream;
            }
          },
          on: function(eventName, callback2) {
            return this;
          },
          send: function(callback2) {
            callback2(storedResult.reject, storedResult.resolve);
          },
          abort: function() {
          }
        };
        const _client = client;
        const config = _client.config || _client.options || _AWS.config;
        if (config.paramValidation) {
          try {
            const inputRules = (_client.api && _client.api.operations[method] || _client[method] || {}).input;
            if (inputRules) {
              const params = userArgs[(userArgs.length || 1) - 1];
              new _AWS.ParamValidator((_client.config || _AWS.config).paramValidation).validate(inputRules, params);
            }
          } catch (e) {
            callback(e, null);
            return request;
          }
        }
        if (replace instanceof Function) {
          const concatUserArgs = userArgs.concat([callback]);
          const result = replace.apply(replace, concatUserArgs);
          if (storedResult === void 0 && result != null && (typeof result === "object" && result.then instanceof Function || result instanceof Readable)) {
            storedResult = result;
          }
        } else {
          callback(null, replace);
        }
        return request;
      });
    }
    function restore(service, method) {
      if (!service) {
        restoreAllServices();
      } else {
        if (method) {
          restoreMethod(service, method);
        } else {
          restoreService(service);
        }
      }
    }
    function restoreAllServices() {
      for (let serviceKey in services) {
        const service = serviceKey;
        restoreService(service);
      }
    }
    function restoreService(service) {
      if (services[service]) {
        restoreAllMethods(service);
        const serviceObj = services[service];
        if (serviceObj) {
          const stubFun = services[service]?.stub;
          if (stubFun) {
            stubFun.restore();
          }
        }
        delete services[service];
      } else {
        console.log("Service " + service + " was never instantiated yet you try to restore it.");
      }
    }
    function restoreAllMethods(service) {
      for (const method in services[service]?.methodMocks) {
        const methodName = method;
        restoreMethod(service, methodName);
      }
    }
    function restoreMethod(service, method) {
      const methodName = method;
      const serviceObj = services[service];
      if (!serviceObj) {
        console.log("Method " + service + " was never instantiated yet you try to restore it.");
        return;
      }
      const serviceClients = services[service]?.clients;
      if (serviceClients) {
        serviceClients.forEach((client) => {
          const mockedClientMethod = client[methodName];
          if (mockedClientMethod && typeof mockedClientMethod.restore === "function") {
            mockedClientMethod.restore();
          }
        });
      }
      delete services[service]?.methodMocks[methodName];
    }
    (function() {
      const setPromisesDependency = _AWS.config.setPromisesDependency;
      if (typeof setPromisesDependency === "function") {
        AWS.Promise = global.Promise;
        _AWS.config.setPromisesDependency = function(p) {
          AWS.Promise = p;
          return setPromisesDependency(p);
        };
      }
    })();
    module.exports = AWS;
  }
});
export default require_src();
